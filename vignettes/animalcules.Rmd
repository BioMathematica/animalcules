---
title: "Animalcules"
author:
- name: Yue Zhao
  affiliation:
  - &1 Section of Computational Biomedicine, Boston University, Boston, MA
- name: Anthony Federico
  affiliation:
  - *1
- name: Lucas Schiffer
  affiliation:
  - *1
date: '`r format(Sys.Date(), "%B %e, %Y")`'
abstract: >
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vitae sapien
    at odio vehicula hendrerit. Curabitur finibus scelerisque ex volutpat
    rhoncus. Mauris vel arcu placerat dui posuere mattis. Mauris laoreet pretium
    purus, eu volutpat tellus egestas vel. Quisque ornare eros ut nulla finibus
    lobortis. Praesent dictum pellentesque est a mattis. Suspendisse id rhoncus
    purus.
package: animalculinstales
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{animalcules}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
---

# Knitr Options

```{r}
knitr::opts_chunk$set(message = FALSE)
```

# Packages

```{r}
#library(tidyverse)
library(magrittr)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(S4Vectors)
library(usethis)
library(dplyr)
library(plotly)
library(reshape2)
library(caret)
library(vegan)
library(ape)
library(gbm)
library(DESeq2)
```

# Toy Dataset

```{r}
# data_raw <-
#     base::system.file("extdata/animalcules.rds", package = "animalcules") %>%
#     base::readRDS()
# 
# se_mgx <-
#     magrittr::use_series(data_raw, count_table) %>%
#     base::data.matrix() %>%
#     S4Vectors::SimpleList() %>%
#     magrittr::set_names("MGX")
# 
# se_ge <-
#     magrittr::use_series(data_raw, gene_expression_table) %>%
#     base::data.matrix() %>%
#     S4Vectors::SimpleList() %>%
#     magrittr::set_names("GeneExpression")
# 
# se_colData <-
#     magrittr::use_series(data_raw, metadata_table) %>%
#     S4Vectors::DataFrame()
# 
# se_rowData <-
#     magrittr::use_series(data_raw, tax_table) %>%
#     base::data.frame() %>%
#     dplyr::mutate_all(as.character) %>%
#     dplyr::select(superkingdom, phylum, class, order, family, genus) %>%
#     S4Vectors::DataFrame()
# 
# microbe_se <-
#     SummarizedExperiment::SummarizedExperiment(assays = se_mgx,
#                                                colData = se_colData,
#                                                rowData = se_rowData)
# 
# host_se <-
#     SummarizedExperiment::SummarizedExperiment(assays = se_ge,
#                                                colData = se_colData)
# 
# mae_experiments <-
#     S4Vectors::SimpleList(MicrobeGenetics = microbe_se, HostGenetics = host_se)
# 
# MAE <-
#     MultiAssayExperiment::MultiAssayExperiment(experiments = mae_experiments,
#                                                colData = se_colData)
# 
# # usethis::use_data(MAE)
```

# Toy Test

```{r}
load("data/MAE.rda")
MultiAssayExperiment::experiments(MAE)
MultiAssayExperiment::colData(MAE)
MultiAssayExperiment::sampleMap(MAE)
```

```{r}
sessionInfo()
```

# Utility Functions

```{r}
upsample_counts <- function(counts_table, tax_table, higher_level) {
    counts_table$higher_level = tax_table[[higher_level]]
    counts_table <- reshape2::melt(counts_table, id.vars="higher_level") %>%
        aggregate(.~variable+higher_level, . , sum) %>%
        reshape2::dcast(higher_level~variable) %>%
        as.data.frame()
    rownames(counts_table) <- counts_table$higher_level
    counts_table$higher_level <- NULL
    return(counts_table)
}

counts_to_relabu <- function(counts_table) {
    sapply(counts_table, prop.table) %>%
        as.data.frame() %>%
        magrittr::set_colnames(colnames(counts_table)) %>%
        magrittr::set_rownames(rownames(counts_table))
}

counts_to_logcpm <- function(counts_table) {
    sapply(counts_table, function(x) log10(x*1e6/sum(x) + 1)) %>%
        as.data.frame() %>%
        magrittr::set_colnames(colnames(counts_table)) %>%
        magrittr::set_rownames(rownames(counts_table))
}

pick_samples <- function(df, isolate_samples, discard_samples) {
    # Isolate all of these samples
    if (!is.null(isolate_samples)) {
        df <- dplyr::select(df, one_of(isolate_samples))
    }
    # Discard all of these samples
    if (!is.null(discard_samples)) {
        df <- dplyr::select(df, -one_of(discard_samples))
    }
    return(df)
}

pick_samples_MAE <- function(MAE, isolate_samples=NULL, discard_samples=NULL) {
    # Isolate all of these samples
    if (!is.null(isolate_samples)) {
        MAE <- MAE[,isolate_samples,]
    }
    # Discard all of these samples
    if (!is.null(discard_samples)) {
        id = rownames(colData(MAE))
        id_isolate = id[!id %in% discard_samples]
        MAE <- MAE[,id_isolate,]
    }
    return(MAE)
}

df_char_to_factor <- function(df) {
    for (i in 1:ncol(df)){
        if (type(df[,i,drop=F]) == "character"){
            df[,i] <- as.factor(df[,i])
        }
    }
    return(df)
}


percent <- function(x, digits = 2, format = "f") {
    paste0(formatC(100 * x, format = format, digits = digits), "%")
}

```

# Server_02_filter

## Objects Define

```{r}
## tables from MAE
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample
```

## Filter MAE by discarding samples

```{r}
samples_discard = c("subject_2", "subject_4")
MAE_subset <- pick_samples_MAE(MAE = MAE, discard_samples = samples_discard)
```

## Summary Plot Top

```{r}
filter_type = "By Microbes"
sample_condition = "AGE"

##
# Add count summary data to sample table
sam_table[,"Reads"] = colSums(counts_table[,rownames(sam_table)])
sam_table[,"Taxnum"] = apply(counts_table , 2, function(x) sum(x >= 1))

if (filter_type == "By Microbes") {
    cov <- "Taxnum"
} else {
    cov <- sample_condition
}

# Use density plot if the variable has more than 8 unique values
# Use pie chart if the variable has less than 8 unique values
if (length(unique(unlist(sam_table[,cov]))) > 8) {
    vec <- unlist(sam_table[,cov])
    num.scatter <- plot_ly(y = vec, 
                          jitter = 0.3, 
                          pointpos = -1.8, 
                          boxpoints = 'all',
                          marker = list(color = 'rgb(7,40,89)'),
                          line = list(color = 'rgb(7,40,89)'),
                          name = cov, type="box") %>%
                          layout(title=cov)
    num.scatter$elementId <- NULL
    num.scatter
} else {
    cat.df = data.frame(table(sam_table[,cov]))
    cat.pie <- plot_ly(cat.df, labels = ~Var1, values = ~Freq,
                       type = "pie",
                       showlegend = FALSE) %>%
                       layout(title=cov)
    cat.pie$elementId <- NULL
    cat.pie
}
```

## Summary Plot Bottom

```{r}
filter_type = "By Metadata"
sample_condition = "SEX"

sam_table[,"Reads"] = colSums(counts_table[,rownames(sam_table)])
sam_table[,"Taxnum"] = apply(counts_table , 2, function(x) sum(x >= 1))

if (filter_type == "By Microbes") {
    cov <- "Taxnum"
} else {
    cov <- sample_condition
}

# Use density plot if the variable has more than 8 unique values
# Use bar plot if the variable has less than 8 unique values
if (length(unique(unlist(sam_table[,cov]))) > 8) {
    fit <- density(unlist(sam_table[,cov]))
    num.density <- plot_ly(x=fit$x, y=fit$y, 
                           type="scatter", 
                           mode="lines", 
                           fill="tozeroy") %>%
                           layout(title=cov)
    num.density$elementId <- NULL
    num.density
} else {
    cat.df = data.frame(table(sam_table[,cov]))
    cat.bar <- plot_ly(x = cat.df$Var1,
                       y = cat.df$Freq,
                       type = "bar",
                       showlegend = FALSE) %>%
                layout(title=cov,
                       xaxis = list(tickmode = "array",
                                    showticklabels = TRUE,
                                    categoryorder = 'trace'),
                       yaxis = list(title = 'Frequency'))
    cat.bar$elementId <- NULL
    cat.bar
}
```

## Categorize

```{r}
MAE <- readRDS("inst/extdata/MAE.rds")
microbe <- MultiAssayExperiment::experiments(MAE)[[1]]
host <- MultiAssayExperiment::experiments(MAE)[[2]]
sam_table <- as.data.frame(colData(microbe)) # sample x condition

sample_condition = "AGE"
nbins = 3 # Auto bin cutoffs
bin_breaks = c(0,55,75,100) # Custom bin cutoffs
bin_labels = c('Young','Adult',"Elderly") # Optional custom labels
new_label = "AGE_GROUP"

##
# Numeric vector according to covariate of interest
unbinned <- as.numeric(unlist(sam_table[,sample_condition]))

# Plot unbinned condition
fit <- density(unbinned)
p <- plot_ly(x=fit$x,
             y=fit$y,
             type="scatter",
             mode="lines",
             fill="tozeroy") %>%
             layout(title=sample_condition,
                    margin = list(l=0,
                                  r=0,
                                  t=30,
                                  b=30))
#p$elementId <- NULL
p

# If bins are provided use those
if (length(bin_breaks) >= 2) {
    nlabs <- length(bin_breaks)-1
} else {
    bin_breaks <- nbins
    nlabs <- nbins
}
# Ensure provided labels are the correct length
if (length(bin_labels) >= 1) {
    stopifnot(length(bin_labels) == nlabs)
}

# Categorized condition
binned <- cut.default(unbinned, bin_breaks, bin_labels)

# Add into sam table
sam_table[,new_label] <- binned

# Plot Binned Condition
p <- plot_ly(y = binned,
             type = "histogram") %>%
             layout(title = new_label,
                    xaxis = list(title = "Frequency"),
                    yaxis = list(title = "Bins"),
                    margin = list(l=80)
    )
#p$elementId <- NULL
p
```

# Server_03_relabu

## Relative Abundance Stacked Bar Plot

```{r}
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

tax_level="genus"
order_organisms=c("Escherichia")
sort_by="conditions" # "conditions"
group_samples=F
group_conditions="DISEASE" # "SEX" "ALL" "DISEASE"
sample_conditions=c("DISEASE")
isolate_samples=c()
discard_samples=c()
show_legend=T

##
# Isolate or discard samples in the counts table
counts_table <- pick_samples(counts_table, isolate_samples, discard_samples)

# Subset and match sam table on the same samples as counts table
sam_table <- sam_table %>%
                .[rownames(.) %in% colnames(counts_table),,drop=F] %>%
                .[match(rownames(.), colnames(counts_table)),,drop=F] %>%
                df_char_to_factor()

# Ensure sam table has the same subset of samples and is in the correct order
stopifnot(colnames(counts_table) == rownames(sam_table))

# Sum counts by taxon level and return relative abundance
relabu_table <- counts_table %>%
                    upsample_counts(tax_table, tax_level) %>%
                    counts_to_relabu() %>%
                    base::t() %>%
                    base::as.data.frame()

# If grouping samples
if (group_samples & !is.null(group_conditions)) {
    if (group_conditions == 'ALL') {
        relabu_table$covariate <- rep('ALL', nrow(relabu_table))
    } else {
        relabu_table$covariate <- sam_table[[group_conditions]]
    }

    # Group relative abundance by the covariate (mean relative abundance across organisms)
    relabu_table <- relabu_table %>%
                        reshape2::melt(id.vars = 'covariate') %>%
                        aggregate(. ~variable+covariate , ., mean) %>%
                        reshape2::dcast(formula = covariate~variable) %>%
                        magrittr::set_rownames(.[['covariate']]) %>%
                        dplyr::select(-one_of(c("covariate")))

    # Sam table becomes the grouped conditions
    sam_table <- rownames(relabu_table) %>%
                     as.data.frame() %>%
                     magrittr::set_colnames(c(group_conditions)) %>%
                     magrittr::set_rownames(rownames(relabu_table))
}

# Put selected organisms first
relabu_table <- relabu_table[,order(colSums(relabu_table)),drop=F]
if (!is.null(order_organisms)) {
    org_order <- c(setdiff(colnames(relabu_table), order_organisms), rev(order_organisms))
    relabu_table <- relabu_table[,org_order]
}

# Order samples by organisms if not by conditons
if (sort_by == "organisms") {
    for (i in 1:ncol(relabu_table)) {
        relabu_table <- relabu_table[order(relabu_table[,i]),]
    }
}

# If any conditions are selected make a side bar
if (!is.null(sample_conditions) || (group_samples && group_conditions != "ALL")) {
    if (!group_samples) {
        sam_table <- sam_table[,sample_conditions,drop=F]
    }

    # Order samples by conditions if not by organisms
    if (sort_by == "conditions") {
        for (i in ncol(sam_table):1) {
            sam_table <- sam_table[order(sam_table[[i]]),,drop=F]
        }
        # Reorder stacked barplot
        relabu_table <- relabu_table[order(match(rownames(relabu_table), rownames(sam_table))),,drop=F]
    } else {
        sam_table <- sam_table[order(match(rownames(sam_table), rownames(relabu_table))),,drop=F]
    }

    if (nrow(sam_table) > 1) {
        # Retain hover-text information before conditions are factorized
        hover.txt <- c()
        for (i in 1:ncol(sam_table)) {
            hover.txt <- cbind(hover.txt, as.character(sam_table[[i]]))
        }

        # Normalized matrix
        mat <- sam_table %>%
                   data.matrix() %>%
                   apply(2, function(x)(x-min(x))/(max(x)-min(x)))

        # Plotly | Heatmap
        hm <- plotly::plot_ly(x = colnames(mat),
                              y = rownames(mat),
                              z = mat,
                              type = "heatmap",
                              showscale=F,
                              hoverinfo = "x+y+text",
                              text=hover.txt) %>%
            layout(xaxis = list(title = "",
                                tickangle = -45),
                   yaxis = list(showticklabels = F,
                                type = 'category',
                                ticks = ""))
    }

}

# Plotly | Stacked Bar Plots
relabu_table$samples <- rownames(relabu_table)
sbp <- plot_ly(relabu_table,
               y = ~samples,
               x = relabu_table[[colnames(relabu_table)[1]]],
               type = 'bar',
               orientation = 'h',
               name = substr(colnames(relabu_table)[1], 1, 40)) %>%
               layout(font = list(size = 10),
                      xaxis = list(title = 'Relative Abundance'),
                      yaxis = list(title = '',
                                   type = 'category',
                      tickmode = "array",
                      tickvals = rownames(relabu_table),
                      showticklabels = FALSE,
                      categoryorder = 'trace'),
                      barmode = 'stack',
                      showlegend = show_legend)
for (i in 2:(ncol(relabu_table)-1)) {
    sbp <- add_trace(sbp, x=relabu_table[[colnames(relabu_table)[i]]], name=substr(colnames(relabu_table)[i], 1, 40))
}

# Create a multiplot if any conditions are selected
if (exists("hm") && nrow(sam_table) > 1) {
    hm_sbp <- subplot(hm, sbp, widths=c(0.1,  0.9))
    hm_sbp$elementId <- NULL # To suppress a shiny warning
    hm_sbp
    #return(hm_sbp)
} else {
    sbp$elementId <- NULL # To suppress a shiny warning
    sbp
    #return(sbp)
}
```

## Relative Abundance Heatmap

```{r}
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample



tax_level="phylum"
sort_by="conditions"
sample_conditions=c("DISEASE")
isolate_organisms=c()
isolate_samples=c()
discard_samples=c()
log_cpm=T

##
# Isolate or discard samples in the counts table
counts_table <- pick_samples(counts_table, isolate_samples, discard_samples)

# Subset and match sam table on the same samples as counts table
sam_table <- sam_table %>%
    .[rownames(.) %in% colnames(counts_table),,drop=F] %>%
    .[match(rownames(.), colnames(counts_table)),,drop=F] %>%
    df_char_to_factor()

# Ensure sam table has the same subset of samples and is in the correct order
stopifnot(colnames(counts_table) == rownames(sam_table))

# Sum counts by taxon level and return counts or logcpm(counts)
counts_table <- counts_table %>%
                    upsample_counts(tax_table, tax_level) %>%
                    {if(log_cpm) counts_to_logcpm(.) else .} %>%
                    base::t() %>%
                    base::as.data.frame()

# Isolate organisms if specified
if (!is.null(isolate_organisms)) {
    counts_table <- counts_table[,isolate_organisms,drop=F]
}

# Reorder by most prominent organisms
counts_table <- counts_table[,order(colSums(counts_table)),drop=F]

# Order samples by organisms if not by conditons
if (sort_by == "organisms") {
    for (i in 1:ncol(counts_table)) {
        counts_table <- counts_table[order(counts_table[,i]),,drop=F]
    }
}

# If any conditions are selected make a side bar
if (!is.null(sample_conditions)) {
    sam_table <- sam_table[,sample_conditions,drop=F]
    if (sort_by == "conditions") {
        for (i in ncol(sam_table):1) {
            sam_table <- sam_table[order(sam_table[[i]]),,drop=F]
        }
        # Reorder stacked barplot
        counts_table <- counts_table[order(match(rownames(counts_table), rownames(sam_table))),,drop=F]
    } else {
        sam_table <- sam_table[order(match(rownames(sam_table), rownames(counts_table))),,drop=F]
    }
}

# Plotly | Heatmap Counts
mat <- data.matrix(counts_table)
hm_c <- plot_ly(x = colnames(mat),
                y = rownames(mat),
                z = mat,
                type = "heatmap",
                colors= "RdPu",
                hoverinfo = "x+y+z") %>%
                layout(xaxis = list(showticklabels = F,
                                    title = "",
                                    ticks = "",
                                    tickangle = -45),
                       yaxis = list(showticklabels = F,
                                    type = 'category',
                                    ticks = ""))

# Plotly | Heatmap Samples
if (!is.null(sample_conditions)) {

    # Retain hover-text information before conditions are factorized
    hover.txt <- c()
    for (i in 1:ncol(sam_table)) {
        hover.txt <- cbind(hover.txt, as.character(sam_table[[i]]))
    }

    # Normalized matrix
    mat <- sam_table %>%
        data.matrix() %>%
        apply(2, function(x)(x-min(x))/(max(x)-min(x)))

    # Plotly | Heatmap Samples
    hm_s <- plot_ly(x = colnames(mat),
                    y = rownames(mat),
                    z = mat,
                    type = "heatmap",
                    showscale=F,
                    hoverinfo = "x+y+text",
                    text=hover.txt) %>%
                    layout(xaxis = list(title = "",
                                        tickangle = -45),
                           yaxis = list(showticklabels = F,
                                        type = 'category',
                                        ticks = ""))
}

# Create a multiplot if any conditions are selected
if (!is.null(sample_conditions)) {
    hm_c_s <- subplot(hm_s, hm_c, widths=c(0.1,  0.9))
    hm_c_s$elementId <- NULL # To suppress a shiny warning
    hm_c_s
    #return(hm_sam_ra)
} else {
    hm_c$elementId <- NULL # To suppress a shiny warning
    hm_c
    #return(hm_c)
}
```

## Relative Abundance Boxplot

```{r}
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

tax_level <- "genus"
organisms <- c("Escherichia", "Actinomyces")
condition <- "DISEASE"
datatype  <- c("counts", "relabu", "logcpm")[3]

##

# Sum counts by taxon level and return counts
df <- counts_table %>%
      # Sum counts by taxon level
      upsample_counts(tax_table, tax_level) %>%
      # Choose data type
      {
          if (datatype == "relabu") {
              counts_to_relabu(.)
          } else if (datatype == "logcpm") {
              counts_to_logcpm(.)
          } else {
              .
          }
      } %>%
      # Subset on chosen organisms
      .[organisms, , drop=F] %>%
      # Transpose
      t() %>%
      # Back to data frame
      as.data.frame() %>%
      # Merge in covariate information
      merge(sam_table[, condition, drop=F], by=0, all=T) %>%
      # Melt for plotly
      reshape2::melt(by=organisms, variable.name="organisms")

p <- plot_ly(df,
             x = ~organisms,
             y = ~value,
             color = ~df[,condition],
             type = "box")  %>%
             layout(boxmode = "group",
                    yaxis = list(title = datatype))
p$p <- NULL # To suppress a shiny warning
p
#return(p)
```


# Server_04_diversity

## alpha diversity boxplot
```{r}
alpha_div_boxplot(MAE = MAE,
                  tax_level = "genus",
                  condition = "DISEASE",
                  alpha_metric = "shannon")
```



## alpha diversity statistical test
```{r}
do_alpha_div_test(MAE = MAE,
                  tax_level = "genus",
                  condition = "DISEASE",
                  alpha_metric = "shannon",
                  alpha_stat = "T-test")

```

## beta diversity heatmap
```{r}
diversity_beta_heatmap(MAE = MAE, 
                       tax_level = 'genus', 
                       input_bdhm_select_conditions = 'DISEASE',
                       input_bdhm_sort_by = 'condition')

```

## beta boxplot
```{r}
diversity_beta_boxplot(MAE = MAE, 
                       tax_level = 'genus', 
                       input_select_beta_condition = 'DISEASE')
```

## beta diversity stat
```{r}
diversity_beta_test(MAE = MAE, 
                    tax_level = 'genus',
                    input_select_beta_condition =  'DISEASE',
                    input_select_beta_stat_method = 'PERMANOVA',
                    input_num_permutation_permanova = 999)
```

# Server_05_dimred

# PCA
```{r}
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

color <- "SEX"
shape <- "DISEASE"
pcy <- 1
pcx <- 2
tax_level <- "phylum"
datatype  <- c("counts", "relabu", "logcpm")[3]

##

# Sum counts by taxon level and return counts
df <- counts_table %>%
      # Sum counts by taxon level
      upsample_counts(tax_table, tax_level) %>%
      # Choose data type
      {
          if (datatype == "relabu") {
              counts_to_relabu(.)
          } else if (datatype == "logcpm") {
              counts_to_logcpm(.)
          } else {
              .
          }
      } %>%
      # Fix constant/zero row
      {
          if (sum(rowSums(as.matrix(.)) == 0) > 0){
              . <- .[-which(rowSums(as.matrix(.)) == 0),]
           } else {
               .
           }
      } %>%
      # Transpose
      t()

# PCA
df.prcomp <- stats::prcomp(df, scale=T)
# Principle Components
df.pca <- df.prcomp$x
# Importance
df.imp <- t(summary(df.prcomp)$importance)

# Merge in covariate information
if (!is.null(shape)) {
    df.pca.m <- merge(df.pca, sam_table[, c(color, shape), drop=F], by=0, all=T)
} else {
    df.pca.m <- merge(df.pca, sam_table[, color, drop=F], by=0, all=T)
    shape <- 'shape' # Referenced by plotly later
    df.pca.m[[shape]] <- 1 # Constant results in omitting shape
}

# Plotly | Scatterplot
p <- plot_ly(df.pca.m,
             x = as.formula(paste("~PC", pcx, sep = "")),
             y = as.formula(paste("~PC", pcy, sep = "")),
             mode = "markers",
             color = as.formula(paste("~", color, sep = "")),
             symbol = as.formula(paste("~", shape, sep = "")),
             type = "scatter",
             text = df.pca.m$Row.names,
             marker = list(size = 10))

p$p <- NULL # To suppress a shiny warning
p
#return(p)

# Formatting importance table
colnames(df.imp) = c("Standard Deviation",
                     "Variance Explained",
                     "Cumulative Variance")

# Show variance as a percentage
df.imp[,2] <- scales::percent(as.numeric(df.imp[,2]))
df.imp[,3] <- scales::percent(as.numeric(df.imp[,3]))

df.imp
```

# PCoA
```{r}
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
host <- MAE[['HostGenetics']]
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

color <- "SEX"
shape <- "DISEASE"
axy <- 1
axx <- 2
tax_level <- "phylum"
method  <- c("bray", "wunifrac")[1]

##

# Sum counts by taxon level and return counts
df <- counts_table %>%
    # Sum counts by taxon level
    upsample_counts(tax_table, tax_level) %>%
    # Fix constant/zero row
    {
        if (sum(rowSums(as.matrix(.)) == 0) > 0){
            . <- .[-which(rowSums(as.matrix(.)) == 0),]
        } else {
            .
        }
    } %>%
    # Transpose
    t()

# Distance metrics
if (method == "bray") {
    df.dist <- vegan::vegdist(df, method="bray")
}

# PCoA
df.apcoa <- ape::pcoa(df.dist)
# Principle Coordinates
df.pcoa <- df.apcoa$vectors
# Importance
df.imp <- df.apcoa$values

# Merge in covariate information
if (!is.null(shape)) {
    df.pcoa.m <- merge(df.pcoa, sam_table[, c(color, shape), drop=F], by=0, all=T)
} else {
    df.pcoa.m <- merge(df.pcoa, sam_table[, color, drop=F], by=0, all=T)
    shape <- 'shape' # Referenced by plotly later
    df.pcoa.m[[shape]] <- 1 # Constant results in omitting shape
}

# Plotly | Scatterplot
p <- plot_ly(df.pcoa.m,
             x = as.formula(paste("~Axis.", axx, sep = "")),
             y = as.formula(paste("~Axis.", axy, sep = "")),
             mode = "markers",
             color = as.formula(paste("~", color, sep = "")),
             symbol = as.formula(paste("~", shape, sep = "")),
             type = "scatter",
             text = df.pcoa.m$Row.names,
             marker = list(size = 10))

p$p <- NULL # To suppress a shiny warning
p
#return(p)

# Formatting importance table
df.imp <- df.imp[,c(1,3,5)]
rownames(df.imp) <- paste("Axis", 1:nrow(df.imp), sep = ".")
colnames(df.imp) <- c("Eigenvalue",
                      "Variance Explained",
                      "Cumulative Variance")

# Show variance as a percentage
df.imp[,2] <- scales::percent(as.numeric(df.imp[,2]))
df.imp[,3] <- scales::percent(as.numeric(df.imp[,3]))

df.imp
```

# Server_06_differential_analysis

```{r}
## tables from MAE
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

## shiny UI input object
tax_level="genus"
input_da_condition=c("DISEASE")
#input_da_condition_covariate=c("SEX")
input_da_condition_covariate=NULL
min_num_filter = 5
input_da_padj_cutoff = 0.05

# Sum counts by taxon level
count_table_tax <- counts_table %>%
                    upsample_counts(tax_table, tax_level)

# sam table
sam_table %<>% df_char_to_factor()

# build the deseq2 formula
if (is.null(input_da_condition_covariate)){
    dds_formula = stats::as.formula(paste("~",input_da_condition, sep = " "))
} else{
    dds_formula = stats::as.formula(paste("~",
                                   paste(
                                       paste(input_da_condition_covariate,
                                             collapse = " + "),
                                       input_da_condition,
                                       sep = " + "),
                                   sep = " "))
}

# run DEseq2
dds <- DESeq2::DESeqDataSetFromMatrix(countData = count_table_tax,
                                      colData = sam_table,
                                      design = dds_formula)
dds <- DESeq2::DESeq(dds)


# filter microbes with less than min_num_filter
keep <- base::rowSums(DESeq2::counts(dds)) >= min_num_filter
dds <- dds[keep,]

res <- DESeq2::results(dds)

# reorder the result
res = res[base::order(res$padj, na.last=NA), ]


# reformat for reporting
if (nrow(res) != 0){
  sigtab = res[(res$padj < input_da_padj_cutoff), ]
  if (nrow(sigtab) == 0){
    as.matrix("No differentially abundant items found!")
  } else{
    sigtab = as(sigtab, "data.frame")
    sigtab$padj <- as.numeric(formatC(sigtab$padj, format = "e", digits = 2))
    sigtab$log2FoldChange <- as.numeric(formatC(sigtab$log2FoldChange, format = "e", digits = 2))
    sigtab$microbe <- rownames(sigtab)
    rownames(sigtab) <- 1:nrow(sigtab)
    sigtab %<>% select(microbe, padj, log2FoldChange)


    num.1 <- c()
    num.2 <- c()
    # transform label into 1 and 0
    label.vec.num = as.character((sam_table %>% select(input_da_condition))[,1])
    label.vec.save <- unique(label.vec.num)
    label.vec.num[label.vec.num == unique(label.vec.num)[1]] <- 1
    label.vec.num[label.vec.num != 1] <- 0
    label.vec.num <- as.numeric(label.vec.num)
    for (i in 1:nrow(sigtab)){
      species.index <- which(rownames(count_table_tax) == sigtab[i,1])
      num.1 <- c(num.1, sum((count_table_tax[species.index,which(label.vec.num == 1)] > 0)))
      num.2 <- c(num.2, sum((count_table_tax[species.index,which(label.vec.num == 0)] > 0)))
    }

    sigtab <- cbind(sigtab, num.1)
    sigtab <- cbind(sigtab, num.2)


    df.output.prevalence <- percent(round((num.1 + num.2)/ncol(count_table_tax),4))
    sigtab <- cbind(sigtab, df.output.prevalence)


    colnames(sigtab)[ncol(sigtab)-2] <- label.vec.save[1]
    colnames(sigtab)[ncol(sigtab)-1] <- label.vec.save[2]
    colnames(sigtab)[ncol(sigtab)] <- "prevalence"


    foldChange <- c()
    for (i in 1:nrow(sigtab)){
    foldChange[i] <- round((max(as.numeric(c((sigtab[i,5] / sum(label.vec.num == 0)),
                                             (sigtab[i,4] / sum(label.vec.num == 1))))) /
                   min(as.numeric(c((sigtab[i,5] / sum(label.vec.num == 0)),
                                    (sigtab[i,4] / sum(label.vec.num == 1)))))), digits = 2)
    }
    sigtab <- cbind(sigtab, foldChange)
    colnames(sigtab)[ncol(sigtab)] <- "Group Size adjusted fold change"
    sigtab

  }

}else{
  as.matrix("No differentially abundant items found!")
}
```

# Server_07_biomarker

## Train biomarker
```{r}
## tables from MAE
microbe <- MAE[['MicrobeGenetics']] #double bracket subsetting is easier
tax_table <- as.data.frame(rowData(microbe)) # organism x taxlev
sam_table <- as.data.frame(colData(microbe)) # sample x condition
counts_table <- as.data.frame(assays(microbe))[,rownames(sam_table)] # organism x sample

## shiny UI input object
tax_level="genus"
input_select_target_biomarker=c("DISEASE")
nfolds = 3
nrepeats = 3
percent_top_biomarker = 0.2
model_name = "logistic regression" # svm, logistic regression, gbm, random forest

# Sum counts by taxon level and return log10 cpm
logcpm_table <- counts_table %>%
                    upsample_counts(tax_table, tax_level) %>%
                    counts_to_logcpm() %>%
                    base::t() %>%
                    base::as.data.frame()


# add target variable
logcpm_table[,'y'] <- sam_table %>%
                        dplyr::pull(input_select_target_biomarker)

# set up classification model prameters
fitControl <- caret::trainControl(## n1-fold CV
                           method = "repeatedcv",
                           number = nfolds,
                           ## repeated n2 times
                           repeats = nrepeats,
                           classProbs = TRUE,
                           summaryFunction = twoClassSummary,
                           sampling = "smote",
                           savePredictions = TRUE)

# choose different model
if (model_name == "logistic regression"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "glmnet",
                tuneLength = 5,
                trControl = fitControl,
                metric = "ROC")
} else if (model_name == "svm"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "svmLinear",
                tuneLength = 5,
                trControl = fitControl,
                metric = "ROC")
} else if (model_name == "gbm"){
    model_fit <- caret::train(y ~ ., 
                 data = logcpm_table, 
                 method = "gbm", 
                 trControl = fitControl,
                 tuneLength = 5,
                 metric = "ROC",
                 ## This last option is actually one
                 ## for gbm() that passes through
                 verbose = FALSE)
} else if (model_name == "random forest"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "ranger", 
                trControl = fitControl,
                tuneLength = 5,
                metric = "ROC",
                # ranger specific parameter
                importance = "impurity")
}

# process the importance score
if (model_name == "svm"){
    svm_importance <- caret::varImp(model_fit)$importance
    svm_importance[,2] <- NULL
    colnames(svm_importance) <- "importance"
    
    biomarker <- svm_importance %>%
                        rownames_to_column() %>%
                        rename(biomarker = rowname) %>%  
                        arrange(importance) %>%
                        filter(importance > quantile(importance, 1-percent_top_biomarker)) %>%
                        select(biomarker) %>%
                        .$biomarker
    
    
    importance_plot <- svm_importance %>%
                        rownames_to_column() %>%
                        rename(biomarker = rowname) %>%  
                        arrange(importance) %>%
                        filter(importance > quantile(importance, 1-percent_top_biomarker)) %>%
                        mutate(biomarker = forcats::fct_inorder(biomarker)) %>%
                        ggplot2::ggplot()+
                        geom_col(aes(x = biomarker, y = importance))+
                        coord_flip()+
                        theme_bw()
    
} else{
    
    biomarker <- caret::varImp(model_fit)$importance %>% 
                      base::as.data.frame() %>%
                      rownames_to_column() %>%
                      rename(importance = Overall) %>%
                      rename(biomarker = rowname) %>%  
                      arrange(importance) %>%
                      filter(importance > quantile(importance, 1-percent_top_biomarker)) %>%
                      select(biomarker) %>%
                      .$biomarker
      
    importance_plot <- caret::varImp(model_fit)$importance %>% 
                      base::as.data.frame() %>%
                      rownames_to_column() %>%
                      rename(importance = Overall) %>%
                      rename(biomarker = rowname) %>%  
                      arrange(importance) %>%
                      filter(importance > quantile(importance, 1-percent_top_biomarker)) %>%
                      mutate(biomarker = forcats::fct_inorder(biomarker)) %>%
                      ggplot2::ggplot()+
                        geom_col(aes(x = biomarker, y = importance))+
                        coord_flip()+
                        theme_bw()
}

# plot the imoportance
importance_plot

# retrain the model using the biomarker
logcpm_table <- logcpm_table %>%
                    select(biomarker,y)

# choose different model
if (model_name == "logistic regression"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "glmnet",
                tuneLength = 5,
                trControl = fitControl,
                metric = "ROC")
} else if (model_name == "svm"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "svmLinear",
                tuneLength = 5,
                trControl = fitControl,
                metric = "ROC")
} else if (model_name == "gbm"){
    model_fit <- caret::train(y ~ ., 
                 data = logcpm_table, 
                 method = "gbm", 
                 trControl = fitControl,
                 tuneLength = 5,
                 metric = "ROC",
                 ## This last option is actually one
                 ## for gbm() that passes through
                 verbose = FALSE)
} else if (model_name == "random forest"){
    model_fit <- caret::train(y ~ ., 
                data = logcpm_table, 
                method = "ranger", 
                trControl = fitControl,
                tuneLength = 5,
                metric = "ROC",
                # ranger specific parameter
                importance = "impurity")
}

# print the biomarker CV performance
model_fit$results %>%
    select(ROC, Sens, Spec) %>%
    filter(ROC == max(ROC))

```
